// File automatically generated by wgsl_bindgen^
//
// ^ wgsl_bindgen version 0.18.1
// Changes made to this file will not be saved.
// SourceHash: dd8555bcbc1fa0c06b1fb34114394e1e0ed6cac797909ae86b124422f8ad1570

#![allow(unused, non_snake_case, non_camel_case_types, non_upper_case_globals)]
#[derive(Clone, Copy, Debug, PartialEq, Eq, Hash)]
pub enum ShaderEntry {
    Pbr,
}
impl ShaderEntry {
    pub fn create_pipeline_layout(&self, device: &wgpu::Device) -> wgpu::PipelineLayout {
        match self {
            Self::Pbr => pbr::create_pipeline_layout(device),
        }
    }
    pub fn create_shader_module_embed_source(
        &self,
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        match self {
            Self::Pbr => pbr::create_shader_module_embed_source(device),
        }
    }
    pub fn create_shader_module_embedded(
        &self,
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
        match self {
            Self::Pbr => pbr::create_shader_module_embedded(device, shader_defs),
        }
    }
    pub fn create_shader_module_from_path(
        &self,
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
        match self {
            Self::Pbr => pbr::create_shader_module_from_path(device, shader_defs),
        }
    }
    pub fn load_shader_module_embedded(
        &self,
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::naga::Module, naga_oil::compose::ComposerError> {
        match self {
            Self::Pbr => pbr::load_shader_module_embedded(composer, shader_defs),
        }
    }
    pub fn load_shader_module_from_path(
        &self,
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::naga::Module, naga_oil::compose::ComposerError> {
        match self {
            Self::Pbr => pbr::load_shader_module_from_path(composer, shader_defs),
        }
    }
    pub fn shader_entry_filename(&self) -> &'static str {
        match self {
            Self::Pbr => "pbr.wgsl",
        }
    }
    pub fn shader_paths(&self) -> &[&str] {
        match self {
            Self::Pbr => pbr::SHADER_PATHS,
        }
    }
}
mod _root {
    pub use super::*;
    pub trait SetBindGroup {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        );
    }
    impl SetBindGroup for wgpu::RenderPass<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
    impl SetBindGroup for wgpu::RenderBundleEncoder<'_> {
        fn set_bind_group(
            &mut self,
            index: u32,
            bind_group: &wgpu::BindGroup,
            offsets: &[wgpu::DynamicOffset],
        ) {
            self.set_bind_group(index, bind_group, offsets);
        }
    }
}
pub mod layout_asserts {
    use super::{_root, _root::*};
    const WGSL_BASE_TYPE_ASSERTS: () = {
        assert!(std::mem::size_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::align_of:: < glam::Vec3A > () == 16);
        assert!(std::mem::size_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::align_of:: < glam::Vec4 > () == 16);
        assert!(std::mem::size_of:: < glam::Mat3A > () == 48);
        assert!(std::mem::align_of:: < glam::Mat3A > () == 16);
        assert!(std::mem::size_of:: < glam::Mat4 > () == 64);
        assert!(std::mem::align_of:: < glam::Mat4 > () == 16);
    };
    const PBR_CAMERA_UNIFORM_ASSERTS: () = {
        assert!(std::mem::offset_of!(pbr::CameraUniform, view_proj) == 0);
        assert!(std::mem::offset_of!(pbr::CameraUniform, position) == 64);
        assert!(std::mem::size_of:: < pbr::CameraUniform > () == 80);
    };
    const PBR_MODEL_UNIFORM_ASSERTS: () = {
        assert!(std::mem::offset_of!(pbr::ModelUniform, model) == 0);
        assert!(std::mem::offset_of!(pbr::ModelUniform, normal_transform) == 64);
        assert!(std::mem::size_of:: < pbr::ModelUniform > () == 112);
    };
    const PBR_MATERIAL_UNIFORM_ASSERTS: () = {
        assert!(std::mem::offset_of!(pbr::MaterialUniform, base_color_factor) == 0);
        assert!(std::mem::offset_of!(pbr::MaterialUniform, metallic_factor) == 16);
        assert!(std::mem::offset_of!(pbr::MaterialUniform, roughness_factor) == 20);
        assert!(std::mem::size_of:: < pbr::MaterialUniform > () == 32);
    };
}
pub mod pbr {
    use super::{_root, _root::*};
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct VertexInput {
        pub position: glam::Vec3A,
        pub normal: glam::Vec3A,
        pub uv: [f32; 2],
    }
    impl VertexInput {
        pub const fn new(
            position: glam::Vec3A,
            normal: glam::Vec3A,
            uv: [f32; 2],
        ) -> Self {
            Self { position, normal, uv }
        }
    }
    impl VertexInput {
        pub const VERTEX_ATTRIBUTES: [wgpu::VertexAttribute; 3] = [
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(Self, position) as u64,
                shader_location: 0,
            },
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x3,
                offset: std::mem::offset_of!(Self, normal) as u64,
                shader_location: 1,
            },
            wgpu::VertexAttribute {
                format: wgpu::VertexFormat::Float32x2,
                offset: std::mem::offset_of!(Self, uv) as u64,
                shader_location: 2,
            },
        ];
        pub const fn vertex_buffer_layout(
            step_mode: wgpu::VertexStepMode,
        ) -> wgpu::VertexBufferLayout<'static> {
            wgpu::VertexBufferLayout {
                array_stride: std::mem::size_of::<Self>() as u64,
                step_mode,
                attributes: &Self::VERTEX_ATTRIBUTES,
            }
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct CameraUniform {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub view_proj: glam::Mat4,
        /// size: 12, offset: 0x40, type: `vec3<f32>`
        pub position: glam::Vec3A,
    }
    pub const fn CameraUniform(
        view_proj: glam::Mat4,
        position: glam::Vec3A,
    ) -> CameraUniform {
        CameraUniform {
            view_proj,
            position,
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct ModelUniform {
        /// size: 64, offset: 0x0, type: `mat4x4<f32>`
        pub model: glam::Mat4,
        /// size: 48, offset: 0x40, type: `mat3x3<f32>`
        pub normal_transform: glam::Mat3A,
    }
    pub const fn ModelUniform(
        model: glam::Mat4,
        normal_transform: glam::Mat3A,
    ) -> ModelUniform {
        ModelUniform {
            model,
            normal_transform,
        }
    }
    #[repr(C, align(16))]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct MaterialUniform {
        /// size: 16, offset: 0x0, type: `vec4<f32>`
        pub base_color_factor: glam::Vec4,
        /// size: 4, offset: 0x10, type: `f32`
        pub metallic_factor: f32,
        /// size: 4, offset: 0x14, type: `f32`
        pub roughness_factor: f32,
        pub _pad_roughness_factor: [u8; 0xC - core::mem::size_of::<f32>()],
    }
    impl MaterialUniform {
        pub const fn new(
            base_color_factor: glam::Vec4,
            metallic_factor: f32,
            roughness_factor: f32,
        ) -> Self {
            Self {
                base_color_factor,
                metallic_factor,
                roughness_factor,
                _pad_roughness_factor: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    #[repr(C)]
    #[derive(Debug, PartialEq, Clone, Copy)]
    pub struct MaterialUniformInit {
        pub base_color_factor: glam::Vec4,
        pub metallic_factor: f32,
        pub roughness_factor: f32,
    }
    impl MaterialUniformInit {
        pub const fn build(&self) -> MaterialUniform {
            MaterialUniform {
                base_color_factor: self.base_color_factor,
                metallic_factor: self.metallic_factor,
                roughness_factor: self.roughness_factor,
                _pad_roughness_factor: [0; 0xC - core::mem::size_of::<f32>()],
            }
        }
    }
    impl From<MaterialUniformInit> for MaterialUniform {
        fn from(data: MaterialUniformInit) -> Self {
            data.build()
        }
    }
    pub const ENTRY_VS_MAIN: &str = "vs_main";
    pub const ENTRY_FS_MAIN: &str = "fs_main";
    #[derive(Debug)]
    pub struct VertexEntry<const N: usize> {
        pub entry_point: &'static str,
        pub buffers: [wgpu::VertexBufferLayout<'static>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn vertex_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a VertexEntry<N>,
    ) -> wgpu::VertexState<'a> {
        wgpu::VertexState {
            module,
            entry_point: Some(entry.entry_point),
            buffers: &entry.buffers,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn vs_main_entry(vertex_input: wgpu::VertexStepMode) -> VertexEntry<1> {
        VertexEntry {
            entry_point: ENTRY_VS_MAIN,
            buffers: [VertexInput::vertex_buffer_layout(vertex_input)],
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct FragmentEntry<const N: usize> {
        pub entry_point: &'static str,
        pub targets: [Option<wgpu::ColorTargetState>; N],
        pub constants: std::collections::HashMap<String, f64>,
    }
    pub fn fragment_state<'a, const N: usize>(
        module: &'a wgpu::ShaderModule,
        entry: &'a FragmentEntry<N>,
    ) -> wgpu::FragmentState<'a> {
        wgpu::FragmentState {
            module,
            entry_point: Some(entry.entry_point),
            targets: &entry.targets,
            compilation_options: wgpu::PipelineCompilationOptions {
                constants: &entry.constants,
                ..Default::default()
            },
        }
    }
    pub fn fs_main_entry(
        targets: [Option<wgpu::ColorTargetState>; 1],
    ) -> FragmentEntry<1> {
        FragmentEntry {
            entry_point: ENTRY_FS_MAIN,
            targets,
            constants: Default::default(),
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0EntriesParams<'a> {
        pub camera: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup0Entries<'a> {
        pub camera: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup0Entries<'a> {
        pub fn new(params: WgpuBindGroup0EntriesParams<'a>) -> Self {
            Self {
                camera: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.camera),
                },
            }
        }
        pub fn as_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.camera]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.as_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup0(wgpu::BindGroup);
    impl WgpuBindGroup0 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Pbr::BindGroup0::LayoutDescriptor"),
            entries: &[
                /// @binding(0): "camera"
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::pbr::CameraUniform>() as _,
                        ),
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(
            device: &wgpu::Device,
            bindings: WgpuBindGroup0Entries,
        ) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(&device);
            let entries = bindings.as_array();
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        label: Some("Pbr::BindGroup0"),
                        layout: &bind_group_layout,
                        entries: &entries,
                    },
                );
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(0, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1EntriesParams<'a> {
        pub model: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup1Entries<'a> {
        pub model: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup1Entries<'a> {
        pub fn new(params: WgpuBindGroup1EntriesParams<'a>) -> Self {
            Self {
                model: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.model),
                },
            }
        }
        pub fn as_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.model]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.as_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup1(wgpu::BindGroup);
    impl WgpuBindGroup1 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Pbr::BindGroup1::LayoutDescriptor"),
            entries: &[
                /// @binding(0): "model"
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::pbr::ModelUniform>() as _,
                        ),
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(
            device: &wgpu::Device,
            bindings: WgpuBindGroup1Entries,
        ) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(&device);
            let entries = bindings.as_array();
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        label: Some("Pbr::BindGroup1"),
                        layout: &bind_group_layout,
                        entries: &entries,
                    },
                );
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(1, &self.0, &[]);
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2EntriesParams<'a> {
        pub material: wgpu::BufferBinding<'a>,
    }
    #[derive(Clone, Debug)]
    pub struct WgpuBindGroup2Entries<'a> {
        pub material: wgpu::BindGroupEntry<'a>,
    }
    impl<'a> WgpuBindGroup2Entries<'a> {
        pub fn new(params: WgpuBindGroup2EntriesParams<'a>) -> Self {
            Self {
                material: wgpu::BindGroupEntry {
                    binding: 0,
                    resource: wgpu::BindingResource::Buffer(params.material),
                },
            }
        }
        pub fn as_array(self) -> [wgpu::BindGroupEntry<'a>; 1] {
            [self.material]
        }
        pub fn collect<B: FromIterator<wgpu::BindGroupEntry<'a>>>(self) -> B {
            self.as_array().into_iter().collect()
        }
    }
    #[derive(Debug)]
    pub struct WgpuBindGroup2(wgpu::BindGroup);
    impl WgpuBindGroup2 {
        pub const LAYOUT_DESCRIPTOR: wgpu::BindGroupLayoutDescriptor<'static> = wgpu::BindGroupLayoutDescriptor {
            label: Some("Pbr::BindGroup2::LayoutDescriptor"),
            entries: &[
                /// @binding(0): "material"
                wgpu::BindGroupLayoutEntry {
                    binding: 0,
                    visibility: wgpu::ShaderStages::VERTEX_FRAGMENT,
                    ty: wgpu::BindingType::Buffer {
                        ty: wgpu::BufferBindingType::Uniform,
                        has_dynamic_offset: false,
                        min_binding_size: std::num::NonZeroU64::new(
                            std::mem::size_of::<_root::pbr::MaterialUniform>() as _,
                        ),
                    },
                    count: None,
                },
            ],
        };
        pub fn get_bind_group_layout(device: &wgpu::Device) -> wgpu::BindGroupLayout {
            device.create_bind_group_layout(&Self::LAYOUT_DESCRIPTOR)
        }
        pub fn from_bindings(
            device: &wgpu::Device,
            bindings: WgpuBindGroup2Entries,
        ) -> Self {
            let bind_group_layout = Self::get_bind_group_layout(&device);
            let entries = bindings.as_array();
            let bind_group = device
                .create_bind_group(
                    &wgpu::BindGroupDescriptor {
                        label: Some("Pbr::BindGroup2"),
                        layout: &bind_group_layout,
                        entries: &entries,
                    },
                );
            Self(bind_group)
        }
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            pass.set_bind_group(2, &self.0, &[]);
        }
    }
    /// Bind groups can be set individually using their set(render_pass) method, or all at once using `WgpuBindGroups::set`.
    /// For optimal performance with many draw calls, it's recommended to organize bindings into bind groups based on update frequency:
    ///   - Bind group 0: Least frequent updates (e.g. per frame resources)
    ///   - Bind group 1: More frequent updates
    ///   - Bind group 2: More frequent updates
    ///   - Bind group 3: Most frequent updates (e.g. per draw resources)
    #[derive(Debug, Copy, Clone)]
    pub struct WgpuBindGroups<'a> {
        pub bind_group0: &'a WgpuBindGroup0,
        pub bind_group1: &'a WgpuBindGroup1,
        pub bind_group2: &'a WgpuBindGroup2,
    }
    impl<'a> WgpuBindGroups<'a> {
        pub fn set(&self, pass: &mut impl SetBindGroup) {
            self.bind_group0.set(pass);
            self.bind_group1.set(pass);
            self.bind_group2.set(pass);
        }
    }
    #[derive(Debug)]
    pub struct WgpuPipelineLayout;
    impl WgpuPipelineLayout {
        pub fn bind_group_layout_entries(
            entries: [wgpu::BindGroupLayout; 3],
        ) -> [wgpu::BindGroupLayout; 3] {
            entries
        }
    }
    pub fn create_pipeline_layout(device: &wgpu::Device) -> wgpu::PipelineLayout {
        device
            .create_pipeline_layout(
                &wgpu::PipelineLayoutDescriptor {
                    label: Some("Pbr::PipelineLayout"),
                    bind_group_layouts: &[
                        &WgpuBindGroup0::get_bind_group_layout(device),
                        &WgpuBindGroup1::get_bind_group_layout(device),
                        &WgpuBindGroup2::get_bind_group_layout(device),
                    ],
                    push_constant_ranges: &[],
                },
            )
    }
    pub fn create_shader_module_embed_source(
        device: &wgpu::Device,
    ) -> wgpu::ShaderModule {
        let source = std::borrow::Cow::Borrowed(SHADER_STRING);
        device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("pbr.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            })
    }
    pub const SHADER_STRING: &'static str = r#"
struct VertexInput {
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
}

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) world_position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
}

struct CameraUniform {
    view_proj: mat4x4<f32>,
    position: vec3<f32>,
}

struct ModelUniform {
    model: mat4x4<f32>,
    normal_transform: mat3x3<f32>,
}

struct MaterialUniform {
    base_color_factor: vec4<f32>,
    metallic_factor: f32,
    roughness_factor: f32,
}

@group(0) @binding(0) 
var<uniform> camera: CameraUniform;
@group(1) @binding(0) 
var<uniform> model: ModelUniform;
@group(2) @binding(0) 
var<uniform> material: MaterialUniform;

@vertex 
fn vs_main(in: VertexInput) -> VertexOutput {
    var out: VertexOutput;

    let _e3 = model.model;
    let world_pos4_ = (_e3 * vec4<f32>(in.position, 1f));
    out.world_position = world_pos4_.xyz;
    let _e14 = camera.view_proj;
    out.clip_position = (_e14 * world_pos4_);
    let _e19 = model.normal_transform;
    out.normal = normalize((_e19 * in.normal));
    out.uv = in.uv;
    let _e25 = out;
    return _e25;
}

@fragment 
fn fs_main(in_1: VertexOutput) -> @location(0) vec4<f32> {
    let _e2 = material.base_color_factor;
    return _e2;
}
"#;
    pub fn load_shader_module_embedded(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::naga::Module, naga_oil::compose::ComposerError> {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: include_str!("..\\shaders\\pbr.wgsl"),
                file_path: "..\\shaders\\pbr.wgsl",
                shader_defs,
                ..Default::default()
            })
    }
    pub fn create_shader_module_embedded(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
        let mut composer = naga_oil::compose::Composer::default()
            .with_capabilities(wgpu::naga::valid::Capabilities::from_bits_retain(1));
        let module = load_shader_module_embedded(&mut composer, shader_defs)?;
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        let shader_module = device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("pbr.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            });
        Ok(shader_module)
    }
    pub const SHADER_ENTRY_PATH: &str = include_absolute_path::include_absolute_path!(
        "..\\shaders\\pbr.wgsl"
    );
    pub const SHADER_PATHS: &[&str] = &[SHADER_ENTRY_PATH];
    pub fn load_shader_module_from_path(
        composer: &mut naga_oil::compose::Composer,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::naga::Module, naga_oil::compose::ComposerError> {
        composer
            .make_naga_module(naga_oil::compose::NagaModuleDescriptor {
                source: &std::fs::read_to_string(SHADER_ENTRY_PATH).unwrap(),
                file_path: "..\\shaders\\pbr.wgsl",
                shader_defs,
                ..Default::default()
            })
    }
    pub fn create_shader_module_from_path(
        device: &wgpu::Device,
        shader_defs: std::collections::HashMap<String, naga_oil::compose::ShaderDefValue>,
    ) -> Result<wgpu::ShaderModule, naga_oil::compose::ComposerError> {
        let mut composer = naga_oil::compose::Composer::default()
            .with_capabilities(wgpu::naga::valid::Capabilities::from_bits_retain(1));
        let module = load_shader_module_from_path(&mut composer, shader_defs)?;
        let info = wgpu::naga::valid::Validator::new(
                wgpu::naga::valid::ValidationFlags::empty(),
                wgpu::naga::valid::Capabilities::all(),
            )
            .validate(&module)
            .unwrap();
        let shader_string = wgpu::naga::back::wgsl::write_string(
                &module,
                &info,
                wgpu::naga::back::wgsl::WriterFlags::empty(),
            )
            .expect("failed to convert naga module to source");
        let source = std::borrow::Cow::Owned(shader_string);
        let shader_module = device
            .create_shader_module(wgpu::ShaderModuleDescriptor {
                label: Some("pbr.wgsl"),
                source: wgpu::ShaderSource::Wgsl(source),
            });
        Ok(shader_module)
    }
}
pub mod bytemuck_impls {
    use super::{_root, _root::*};
    unsafe impl bytemuck::Zeroable for pbr::VertexInput {}
    unsafe impl bytemuck::Pod for pbr::VertexInput {}
    unsafe impl bytemuck::Zeroable for pbr::CameraUniform {}
    unsafe impl bytemuck::Pod for pbr::CameraUniform {}
    unsafe impl bytemuck::Zeroable for pbr::ModelUniform {}
    unsafe impl bytemuck::Pod for pbr::ModelUniform {}
    unsafe impl bytemuck::Zeroable for pbr::MaterialUniform {}
    unsafe impl bytemuck::Pod for pbr::MaterialUniform {}
}
