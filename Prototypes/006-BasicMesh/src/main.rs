use rustica_render::{RenderWindow, Canvas};
use rustica_render_derive::ShaderProperties;
use rustica_foundation::geometry::{GeometryBuilder, Vertex};
use rustica_graphics::Camera; // Import the Camera struct
use cgmath::{Matrix4, Vector3, Point3}; // Keep Matrix4, Vector3, Point3 for model/positioning

// Define our shader using the ShaderProperties derive macro
#[derive(ShaderProperties)]
#[shader(file = "./src/shaders/mesh_shader.wgsl")] // Path relative to workspace root
struct MeshShader {
    // Vertex attributes
    #[vertex(location = 0)]
    position: [f32; 3],
    #[vertex(location = 1)]
    normal: [f32; 3],

    // Instance attributes
    #[instance(location = 2)]
    model_matrix: [[f32; 4]; 4], // Note: Matrix needs multiple locations
    #[instance(location = 6)] // Starts after model_matrix (loc 2, 3, 4, 5)
    instance_color: [f32; 3],

    // Uniforms
    #[uniform(binding = 0)]
    view_proj_matrix: [[f32; 4]; 4],
    #[uniform(binding = 1)]
    time: f32,
}

// The MeshShaderVertex struct is automatically generated by #[derive(ShaderProperties)]
// We don't need to define it manually.

// Helper function to create cube geometry
// The vertex type `MeshShaderVertex` is generated by the derive macro above.
fn create_cube_geometry(builder: &mut GeometryBuilder<MeshShaderVertex>) {
    let half_size = 0.5;
    // Define the 8 vertices of the cube
    let vertices = [
        // Front face
        ([-half_size, -half_size,  half_size], [0.0, 0.0, 1.0]), // 0 Bottom-left
        ([ half_size, -half_size,  half_size], [0.0, 0.0, 1.0]), // 1 Bottom-right
        ([ half_size,  half_size,  half_size], [0.0, 0.0, 1.0]), // 2 Top-right
        ([-half_size,  half_size,  half_size], [0.0, 0.0, 1.0]), // 3 Top-left
        // Back face
        ([-half_size, -half_size, -half_size], [0.0, 0.0, -1.0]), // 4 Bottom-left
        ([ half_size, -half_size, -half_size], [0.0, 0.0, -1.0]), // 5 Bottom-right
        ([ half_size,  half_size, -half_size], [0.0, 0.0, -1.0]), // 6 Top-right
        ([-half_size,  half_size, -half_size], [0.0, 0.0, -1.0]), // 7 Top-left
        // Top face
        ([-half_size,  half_size,  half_size], [0.0, 1.0, 0.0]), // 8 Top-left Front
        ([ half_size,  half_size,  half_size], [0.0, 1.0, 0.0]), // 9 Top-right Front
        ([ half_size,  half_size, -half_size], [0.0, 1.0, 0.0]), // 10 Top-right Back
        ([-half_size,  half_size, -half_size], [0.0, 1.0, 0.0]), // 11 Top-left Back
        // Bottom face
        ([-half_size, -half_size,  half_size], [0.0, -1.0, 0.0]), // 12 Bottom-left Front
        ([ half_size, -half_size,  half_size], [0.0, -1.0, 0.0]), // 13 Bottom-right Front
        ([ half_size, -half_size, -half_size], [0.0, -1.0, 0.0]), // 14 Bottom-right Back
        ([-half_size, -half_size, -half_size], [0.0, -1.0, 0.0]), // 15 Bottom-left Back
        // Right face
        ([ half_size, -half_size,  half_size], [1.0, 0.0, 0.0]), // 16 Bottom-right Front
        ([ half_size, -half_size, -half_size], [1.0, 0.0, 0.0]), // 17 Bottom-right Back
        ([ half_size,  half_size, -half_size], [1.0, 0.0, 0.0]), // 18 Top-right Back
        ([ half_size,  half_size,  half_size], [1.0, 0.0, 0.0]), // 19 Top-right Front
        // Left face
        ([-half_size, -half_size,  half_size], [-1.0, 0.0, 0.0]), // 20 Bottom-left Front
        ([-half_size, -half_size, -half_size], [-1.0, 0.0, 0.0]), // 21 Bottom-left Back
        ([-half_size,  half_size, -half_size], [-1.0, 0.0, 0.0]), // 22 Top-left Back
        ([-half_size,  half_size,  half_size], [-1.0, 0.0, 0.0]), // 23 Top-left Front
    ];

    let cube_vertices: Vec<MeshShaderVertex> = vertices.iter().map(|(pos, norm)| {
        MeshShaderVertex { position: *pos, normal: *norm }
    }).collect();

    // The indices array is unused because builder.triangle() manages indices.
    // let indices = [ ... ];

    // Add vertices and indices directly (GeometryBuilder needs methods for this)
    // Assuming GeometryBuilder will be updated or we adapt
    // For now, let's manually push vertices and indices if needed,
    // or use triangle() if that's the only way. Using triangle() is less efficient for shared vertices.

    // Let's use triangle() for now, duplicating vertices as needed by the API
    // Front
    builder.triangle(cube_vertices[0], cube_vertices[1], cube_vertices[2]);
    builder.triangle(cube_vertices[0], cube_vertices[2], cube_vertices[3]);
    // Back
    builder.triangle(cube_vertices[4], cube_vertices[5], cube_vertices[6]);
    builder.triangle(cube_vertices[4], cube_vertices[6], cube_vertices[7]);
    // Top
    builder.triangle(cube_vertices[8], cube_vertices[9], cube_vertices[10]);
    builder.triangle(cube_vertices[8], cube_vertices[10], cube_vertices[11]);
    // Bottom
    builder.triangle(cube_vertices[12], cube_vertices[13], cube_vertices[14]);
    builder.triangle(cube_vertices[12], cube_vertices[14], cube_vertices[15]);
    // Right
    builder.triangle(cube_vertices[16], cube_vertices[17], cube_vertices[18]);
    builder.triangle(cube_vertices[16], cube_vertices[18], cube_vertices[19]);
    // Left
    builder.triangle(cube_vertices[20], cube_vertices[21], cube_vertices[22]);
    builder.triangle(cube_vertices[20], cube_vertices[22], cube_vertices[23]);

    // Ideally, GeometryBuilder would have add_vertex and add_index methods
    // builder.vertices.extend_from_slice(&cube_vertices);
    // builder.indices.extend_from_slice(&indices);
}


fn main() -> Result<(), Box<dyn std::error::Error>> {
    // Create a render window and register the shader
    let mut window = RenderWindow::new("006 - Basic Mesh (Instanced Cubes)", 1024, 768);
    let shader_descriptor = MeshShader::descriptor();
    let shader_id = window.register_shader(shader_descriptor);

    // Create cube geometry using the auto-generated MeshShaderVertex type
    let mut builder = GeometryBuilder::<MeshShaderVertex>::new();
    create_cube_geometry(&mut builder);
    let cube_geometry = builder.build();

    // --- Camera Setup ---
    let initial_width = 1024.0;
    let initial_height = 768.0;
    let aspect_ratio = initial_width / initial_height;
    let mut camera = Camera::new(
        Point3::new(10.0, 10.0, 15.0), // eye position
        Point3::new(0.0, 0.0, 0.0),   // target
        Vector3::unit_y(),            // up vector
        45.0,                         // fov (in degrees)
        aspect_ratio,
        0.1,                          // near plane
        100.0,                        // far plane
    );

    // --- Instancing Setup ---
    const GRID_SIZE: i32 = 15; // e.g., 15x15 grid
    const SPACING: f32 = 1.5;
    const FREQUENCY: f32 = 0.5;
    const AMPLITUDE: f32 = 1.5;

    // View-projection matrix will be calculated using the camera object inside the callback

    window.with_frame_callback(move |canvas: &mut Canvas| {
        let time = canvas.time().as_secs_f32();

        // Note: view_proj_matrix is calculated outside for now.
        // If the camera or aspect ratio needs to change dynamically,
        // this calculation should move inside the callback.

        // --- Instance Generation ---
        let mut instances = Vec::new();
        for x in -GRID_SIZE / 2..GRID_SIZE / 2 {
            for z in -GRID_SIZE / 2..GRID_SIZE / 2 {
                let base_pos = Vector3::new(x as f32 * SPACING, 0.0, z as f32 * SPACING);

                // Simple wave calculation
                let dist_from_center = (base_pos.x.powi(2) + base_pos.z.powi(2)).sqrt();
                let y_offset = (dist_from_center * FREQUENCY - time * 2.0).sin() * AMPLITUDE;

                let instance_pos = base_pos + Vector3::new(0.0, y_offset, 0.0);
                let model_matrix = Matrix4::from_translation(instance_pos);

                // Color based on position/wave height
                let normalized_y = (y_offset / AMPLITUDE + 1.0) / 2.0; // Normalize y_offset to 0..1
                let instance_color = [normalized_y, 0.5, 1.0 - normalized_y]; // Example: Blue to Red gradient

                // Create the instance data struct expected by ShaderProperties (plural)
                // Convert cgmath types to raw arrays
                let instance_data = MeshShaderInstances { // Use plural form
                    model_matrix: model_matrix.into(), // Convert Matrix4 to [[f32; 4]; 4]
                    instance_color,
                };
                instances.push(instance_data);
            }
        }

        // --- Drawing ---
        // Calculate the view-projection matrix for the current frame
        let view_proj_matrix = camera.view_projection_matrix();

        // Use draw_with_instances and pump_geometry
        canvas.draw_with_instances(shader_id)
              .uniform("view_proj_matrix", view_proj_matrix) // Pass the calculated matrix
              .uniform("time", time)
              .pump_geometry(&cube_geometry, &instances);
    })
    .run()?;

    Ok(())
}
